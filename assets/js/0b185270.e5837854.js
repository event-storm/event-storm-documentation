"use strict";(self.webpackChunkevent_storm_documentation=self.webpackChunkevent_storm_documentation||[]).push([[4885],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>p});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=r.createContext({}),u=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=u(e.components);return r.createElement(l.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),d=u(n),p=a,h=d["".concat(l,".").concat(p)]||d[p]||m[p]||o;return n?r.createElement(h,i(i({ref:t},c),{},{components:n})):r.createElement(h,i({ref:t},c))}));function p(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,i[1]=s;for(var u=2;u<o;u++)i[u]=n[u];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},5162:(e,t,n)=>{n.d(t,{Z:()=>i});var r=n(7294),a=n(6010);const o="tabItem_Ymn6";function i(e){let{children:t,hidden:n,className:i}=e;return r.createElement("div",{role:"tabpanel",className:(0,a.Z)(o,i),hidden:n},t)}},5488:(e,t,n)=>{n.d(t,{Z:()=>p});var r=n(7462),a=n(7294),o=n(6010),i=n(2389),s=n(7392),l=n(7094),u=n(2466);const c="tabList__CuJ",m="tabItem_LNqP";function d(e){var t,n;const{lazy:i,block:d,defaultValue:p,values:h,groupId:f,className:v}=e,g=a.Children.map(e.children,(e=>{if((0,a.isValidElement)(e)&&"value"in e.props)return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})),y=null!=h?h:g.map((e=>{let{props:{value:t,label:n,attributes:r}}=e;return{value:t,label:n,attributes:r}})),b=(0,s.l)(y,((e,t)=>e.value===t.value));if(b.length>0)throw new Error('Docusaurus error: Duplicate values "'+b.map((e=>e.value)).join(", ")+'" found in <Tabs>. Every value needs to be unique.');const k=null===p?p:null!=(t=null!=p?p:null==(n=g.find((e=>e.props.default)))?void 0:n.props.value)?t:g[0].props.value;if(null!==k&&!y.some((e=>e.value===k)))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+k+'" but none of its children has the corresponding value. Available values are: '+y.map((e=>e.value)).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");const{tabGroupChoices:w,setTabGroupChoices:T}=(0,l.U)(),[E,N]=(0,a.useState)(k),S=[],{blockElementScrollPositionUntilNextRender:x}=(0,u.o5)();if(null!=f){const e=w[f];null!=e&&e!==E&&y.some((t=>t.value===e))&&N(e)}const O=e=>{const t=e.currentTarget,n=S.indexOf(t),r=y[n].value;r!==E&&(x(t),N(r),null!=f&&T(f,String(r)))},j=e=>{var t;let n=null;switch(e.key){case"ArrowRight":{var r;const t=S.indexOf(e.currentTarget)+1;n=null!=(r=S[t])?r:S[0];break}case"ArrowLeft":{var a;const t=S.indexOf(e.currentTarget)-1;n=null!=(a=S[t])?a:S[S.length-1];break}}null==(t=n)||t.focus()};return a.createElement("div",{className:(0,o.Z)("tabs-container",c)},a.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,o.Z)("tabs",{"tabs--block":d},v)},y.map((e=>{let{value:t,label:n,attributes:i}=e;return a.createElement("li",(0,r.Z)({role:"tab",tabIndex:E===t?0:-1,"aria-selected":E===t,key:t,ref:e=>S.push(e),onKeyDown:j,onFocus:O,onClick:O},i,{className:(0,o.Z)("tabs__item",m,null==i?void 0:i.className,{"tabs__item--active":E===t})}),null!=n?n:t)}))),i?(0,a.cloneElement)(g.filter((e=>e.props.value===E))[0],{className:"margin-top--md"}):a.createElement("div",{className:"margin-top--md"},g.map(((e,t)=>(0,a.cloneElement)(e,{key:t,hidden:e.props.value!==E})))))}function p(e){const t=(0,i.Z)();return a.createElement(d,(0,r.Z)({key:String(t)},e))}},3577:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>l,default:()=>p,frontMatter:()=>s,metadata:()=>u,toc:()=>m});var r=n(7462),a=(n(7294),n(3905)),o=n(5488),i=n(5162);const s={id:"faq",title:"FAQ",tags:["guides","introduction","faq"],sidebar_position:4},l=void 0,u={unversionedId:"faq",id:"faq",title:"FAQ",description:"When should I use Event Storm?",source:"@site/docs/FAQ.mdx",sourceDirName:".",slug:"/faq",permalink:"/event-storm-documentation/docs/faq",draft:!1,editUrl:"https://github.com/event-storm/event-storm-documentation/tree/main/docs/FAQ.mdx",tags:[{label:"guides",permalink:"/event-storm-documentation/docs/tags/guides"},{label:"introduction",permalink:"/event-storm-documentation/docs/tags/introduction"},{label:"faq",permalink:"/event-storm-documentation/docs/tags/faq"}],version:"current",sidebarPosition:4,frontMatter:{id:"faq",title:"FAQ",tags:["guides","introduction","faq"],sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"How the API is designed?",permalink:"/event-storm-documentation/docs/concepts/api"},next:{title:"API Overview",permalink:"/event-storm-documentation/docs/api-reference/overview"}},c={},m=[{value:"When should I use Event Storm?",id:"when-should-i-use-event-storm",level:2},{value:"Can Event storm only be used with React?",id:"can-event-storm-only-be-used-with-react",level:2},{value:"How to organize the directory structure?",id:"how-to-organize-the-directory-structure",level:2},{value:"Why the library has no action or reducer?",id:"why-the-library-has-no-action-or-reducer",level:2},{value:"Should I keep everything inside one storm?",id:"should-i-keep-everything-inside-one-storm",level:2},{value:"How to organize the migration to Event storm?",id:"how-to-organize-the-migration-to-event-storm",level:2}],d={toc:m};function p(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,r.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h2",{id:"when-should-i-use-event-storm"},"When should I use Event Storm?"),(0,a.kt)("p",null,"The Event Storm is a general purpose state management solution. You can use the library in large project, as well as in small ones. The library is providing a choice for smaller state's. If you're new to state management at all, you can start with creating a ",(0,a.kt)("a",{parentName:"p",href:"/docs/api-reference/model"},"model"),". "),(0,a.kt)("p",null,"Meanwhile, if you're already an advanced user of state management you can start using the ",(0,a.kt)("a",{parentName:"p",href:"docs/api-reference/storm"},"storm")," directly.\nMore specifically, if you're already using a state management and suffering from performance problems, definetely you need to give a try of the Event storm. The library was initially created ",(0,a.kt)("a",{parentName:"p",href:"/docs/motivation"},"for that reason"),"."),(0,a.kt)("h2",{id:"can-event-storm-only-be-used-with-react"},"Can Event storm only be used with React?"),(0,a.kt)("p",null,"No. You are free to use the library in any environment with any framework(library) you wish. The Event storm is design in to be used in any Javascript hoisted environment(browser, nodejs, native, etc.)."),(0,a.kt)("admonition",{title:"ReactJs binding",type:"info"},(0,a.kt)("p",{parentName:"admonition"},"The Event Storm has an official ",(0,a.kt)("a",{parentName:"p",href:"/docs/bindings/react/overview"},"ReactJs binding"))),(0,a.kt)("h2",{id:"how-to-organize-the-directory-structure"},"How to organize the directory structure?"),(0,a.kt)("p",null,"We are suggesting not to make a separated directory for managing all the storm related stuff. Having simple storm directory with project bindings can be enough in most of the cases."),(0,a.kt)(o.Z,{mdxType:"Tabs"},(0,a.kt)(i.Z,{value:"storm/index.tsx",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"export { default as storm } from './storm';\n// if you're using React\nexport * from './useStorm';\n"))),(0,a.kt)(i.Z,{value:"storm/storm.ts",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"import { createStorm } from 'event-storm';\n\nimport defaultState from './defaultState';\n\nconst storm = createStorm(defaultState);\n\nexport default storm;\n\n"))),(0,a.kt)(i.Z,{value:"storm/defaultState.ts",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"export default {\n  name: 'Bob',\n}\n"))),(0,a.kt)(i.Z,{value:"storm/useStorm.ts",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"// if you're using react\nimport { useStorm as useBaseStorm, usePublish as useBasePublish } from 'react-event-storm';\n\nimport storm from './storm';\n\nexport const useStorm = selectFragment => useBaseStorm(storm, selectFragment);\n\nexport const usePublish = options => useBasePublish(storm, options);\n")))),(0,a.kt)("h2",{id:"why-the-library-has-no-action-or-reducer"},"Why the library has no action or reducer?"),(0,a.kt)("p",null,"The Event Storm is following the KISS principle. The simpler the code, the easier to maintain it. The main reason for having unified actions or reducers, is to ensure that all the updates for the information are done from single sources. Thus it's easier to debug and to find the issues. Unfortunately, as far as the project is being scaled, there is moreoften need to update the same state from multiple action/reducers, and the abstraction is bringing more overhead, rather than solving real problem."),(0,a.kt)("p",null,"The Event Storm library suggests to keep the information updates from a single functions and call them directly. There is no need to keep the centralized condition determinator to make the updates just with that functions. Furthermore, the keeping the updates as simple as function will decrease the boilerplate when trying to add some updater dynamically."),(0,a.kt)("h2",{id:"should-i-keep-everything-inside-one-storm"},"Should I keep everything inside one storm?"),(0,a.kt)("p",null,"The library is not limited to just one storm instance. It is possible to create as many library instances as you need. You can relay on your use-case and separate the application information in a modular manner. You can also use ",(0,a.kt)("a",{parentName:"p",href:"/docs/api-reference/model"},"models")," when dealing with a single shared information units."),(0,a.kt)("h2",{id:"how-to-organize-the-migration-to-event-storm"},"How to organize the migration to Event storm?"),(0,a.kt)("p",null,"The Event Storm is designed to be an easy replacement for existing state management solutions. For that reason the naming is mostly kept the same. When migrating from action/reducer architecture(e.g. Redux) you can:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"specify your reducers as a separate functions"),(0,a.kt)("li",{parentName:"ul"},"get rid of actions and actions types"),(0,a.kt)("li",{parentName:"ul"},"replace dispatching actions to calling the direct update functions")),(0,a.kt)("p",null,"If you're using React:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"The library has no React.Provider, so you can simple get rid of it"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"/docs/bindings/react/api-reference/useStorm"},"useStorm")," is similiar to other state management hooks. You can skip using the ",(0,a.kt)("a",{parentName:"li",href:"/docs/bindings/react/api-reference/useStorm#tselectfragment"},"second argument")," for the first migration phase. By default the subscription function will be assigned to subscribe to whole store. You can address the performance optimizations later.")))}p.isMDXComponent=!0}}]);