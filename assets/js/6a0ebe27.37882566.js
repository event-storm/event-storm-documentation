"use strict";(self.webpackChunkevent_storm_documentation=self.webpackChunkevent_storm_documentation||[]).push([[804],{3905:(e,t,r)=>{r.d(t,{Zo:()=>d,kt:()=>u});var a=r(7294);function n(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function o(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,a)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?o(Object(r),!0).forEach((function(t){n(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function l(e,t){if(null==e)return{};var r,a,n=function(e,t){if(null==e)return{};var r,a,n={},o=Object.keys(e);for(a=0;a<o.length;a++)r=o[a],t.indexOf(r)>=0||(n[r]=e[r]);return n}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)r=o[a],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(n[r]=e[r])}return n}var s=a.createContext({}),m=function(e){var t=a.useContext(s),r=t;return e&&(r="function"==typeof e?e(t):i(i({},t),e)),r},d=function(e){var t=m(e.components);return a.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var r=e.components,n=e.mdxType,o=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),c=m(r),u=n,h=c["".concat(s,".").concat(u)]||c[u]||p[u]||o;return r?a.createElement(h,i(i({ref:t},d),{},{components:r})):a.createElement(h,i({ref:t},d))}));function u(e,t){var r=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var o=r.length,i=new Array(o);i[0]=c;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:n,i[1]=l;for(var m=2;m<o;m++)i[m]=r[m];return a.createElement.apply(null,i)}return a.createElement.apply(null,r)}c.displayName="MDXCreateElement"},2635:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>p,frontMatter:()=>o,metadata:()=>l,toc:()=>m});var a=r(7462),n=(r(7294),r(3905));const o={id:"storm",title:"Storm",tags:["api","storm","store","api-reference"],sidebar_position:1},i=void 0,l={unversionedId:"api-reference/storm",id:"api-reference/storm",title:"Storm",description:"In general, in event sourcing technology there is no place to have a centralized single information segment. In contrast to having this, the composition and deriving the real information is suggested. The Event Storm library suggests for this purpose usage of virtual models. On the other hand, it's straightforward, that at scale this will result in a lot of boilerplate code. That\u2019s why the library is suggesting a store concept which has the full power of decentralized data store.",source:"@site/docs/api-reference/storm.md",sourceDirName:"api-reference",slug:"/api-reference/storm",permalink:"/event-storm-documentation/docs/api-reference/storm",draft:!1,editUrl:"https://github.com/event-storm/event-storm-documentation/tree/main/api-reference/storm.md",tags:[{label:"api",permalink:"/event-storm-documentation/docs/tags/api"},{label:"storm",permalink:"/event-storm-documentation/docs/tags/storm"},{label:"store",permalink:"/event-storm-documentation/docs/tags/store"},{label:"api-reference",permalink:"/event-storm-documentation/docs/tags/api-reference"}],version:"current",sidebarPosition:1,frontMatter:{id:"storm",title:"Storm",tags:["api","storm","store","api-reference"],sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"API Overview",permalink:"/event-storm-documentation/docs/api-reference/overview"},next:{title:"Model",permalink:"/event-storm-documentation/docs/api-reference/model"}},s={},m=[{value:"createStorm",id:"createstorm",level:2},{value:"Methods",id:"methods",level:3},{value:"IStorm",id:"istorm",level:2},{value:"IStormSubscription",id:"istormsubscription",level:3},{value:"IStormMiddleware",id:"istormmiddleware",level:3},{value:"IStormState",id:"istormstate",level:3},{value:"AnyObject",id:"anyobject",level:4}],d={toc:m};function p(e){let{components:t,...r}=e;return(0,n.kt)("wrapper",(0,a.Z)({},d,r,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("p",null,"In general, in event sourcing technology there is no place to have a centralized single information segment. In contrast to having this, the composition and deriving the real information is suggested. The Event Storm library suggests for this purpose usage of ",(0,n.kt)("a",{parentName:"p",href:"/event-storm-documentation/docs/api-reference/virtualmodel"},"virtual models"),". On the other hand, it's straightforward, that at scale this will result in a lot of boilerplate code. That\u2019s why the library is suggesting a store concept which has the full power of decentralized data store.\nWhat does this mean? The library will organize subscrition and data store updates in such a manner to keep track of individual subscription and and individual updates. In other words, The Event Storm claims to update only for the given subscription."),(0,n.kt)("h2",{id:"createstorm"},"createStorm"),(0,n.kt)("p",null,"The Event Storm library is providing a ",(0,n.kt)("inlineCode",{parentName:"p"},"createStorm")," method. The function supports a single argument, the default state."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-typescript"},"import { createStorm } from 'event-storm';\n\nconst store = createStorm({\n  taxes: 20,\n  grossSalary: 100_000,\n});\n\nconsole.log(store.getState()) // { taxes: 20, grossSalary: 100_000 }\n")),(0,n.kt)("h3",{id:"methods"},"Methods"),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",{parentName:"tr",align:null},"Method"),(0,n.kt)("th",{parentName:"tr",align:null},"Type"),(0,n.kt)("th",{parentName:"tr",align:null},"Description"))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"createStorm"),(0,n.kt)("td",{parentName:"tr",align:null},"<","T extends ",(0,n.kt)("a",{parentName:"td",href:"#anyobject"},"AnyObject"),">(data: T): ","[IStorm]","(#istorm","<","T>"),(0,n.kt)("td",{parentName:"tr",align:null},"Pass the store initial state to the ",(0,n.kt)("inlineCode",{parentName:"td"},"createStorm"),". The return will be ",(0,n.kt)("a",{parentName:"td",href:"#istorm"},"storm"),".")))),(0,n.kt)("h2",{id:"istorm"},"IStorm"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-typescript"},"interface IStorm<T> {\n  getState: () => IStormState<T>;\n  subscribe: (callback: IStormSubscription<T>) => () => void;\n  addMiddleware: (middleware: IStormMiddleware) => () => void;\n  dispatch: (segments: Partial<T> | ((params: IStormState<T>) => Partial<T>), options?: AnyObject) => void;\n}\n")),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",{parentName:"tr",align:null},"Method"),(0,n.kt)("th",{parentName:"tr",align:null},"Type"),(0,n.kt)("th",{parentName:"tr",align:null},"Description"))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"getState"),(0,n.kt)("td",{parentName:"tr",align:null},"() => ",(0,n.kt)("a",{parentName:"td",href:"#istormstate"},"IStormState"),"<","T>"),(0,n.kt)("td",{parentName:"tr",align:null},"The method will return the actual state of the storm")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"subscribe"),(0,n.kt)("td",{parentName:"tr",align:null},"(callback: ",(0,n.kt)("a",{parentName:"td",href:"#istormsubscription"},"IStormSubscription"),"<","T>) => () => void"),(0,n.kt)("td",{parentName:"tr",align:null},"The method will receive a subscription function. The return value of this method can be called to unsubcribe")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"dispatch"),(0,n.kt)("td",{parentName:"tr",align:null},"(segments: Partial","<","T>"),(0,n.kt)("td",{parentName:"tr",align:null},"((params: ",(0,n.kt)("a",{parentName:"td",href:"#istormstate"},"IStormState"),"<","T>) => Partial","<","T>), options?: ",(0,n.kt)("a",{parentName:"td",href:"#anyobject"},"AnyObject"),") => void")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"addMiddleware"),(0,n.kt)("td",{parentName:"tr",align:null},"(middleware: ",(0,n.kt)("a",{parentName:"td",href:"#istormmiddleware"},"IStormMiddleware"),") => () => void"),(0,n.kt)("td",{parentName:"tr",align:null},"Provide a middleware to the storm. The middleware will be called before any update to the storm.")))),(0,n.kt)("h3",{id:"istormsubscription"},"IStormSubscription"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-typescript"},"type IStormSubscription<T, G = any> = (state: IStormState<T>, subscribe: (state: G) => G) => void\n")),(0,n.kt)("p",null,"To subcribe to a particular section use the second argument of the sucbcription function. E.g. ",(0,n.kt)("inlineCode",{parentName:"p"},"subcribe(state.desired)"),". Pass any part of the ",(0,n.kt)("a",{parentName:"p",href:"#istormstate"},"IStormState")," to the second argument and you'll subscribe only for those changes. "),(0,n.kt)("h3",{id:"istormmiddleware"},"IStormMiddleware"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-typescript"},"type IStormMiddleware<T> = (nextState: IStormState<T>, prevState: IStormState<T>, configs: AnyObject) => void\n")),(0,n.kt)("p",null,"The middleware will be provided the next state, prev state and the corresponding dispatch configuration. Note, the middleware will be called before the storm update."),(0,n.kt)("h3",{id:"istormstate"},"IStormState"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-typescript"},"type IStormState<Type> = {\n  [Property in keyof Type]: Type[Property];\n};\n")),(0,n.kt)("h4",{id:"anyobject"},"AnyObject"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-typescript"},"type AnyObject = Record<string, any>;\n")))}p.isMDXComponent=!0}}]);